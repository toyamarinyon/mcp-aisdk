Okay, I understand. You have a JSON definition of your tools (or you *want* to have one) and you need to generate the corresponding TypeScript code using the `ai` SDK's `tool` function and `zod` for parameter validation, based on the reference code you provided.

It seems the "tools json" you provided is actually the *target* TypeScript code format again, not a JSON representation. Let's assume you have (or will have) a JSON structure that looks something like the standard OpenAI Function Calling JSON schema.

Here's a typical JSON structure for defining tools:

```json
[
  {
    "name": "get_weather",
    "description": "Get the current weather in a given location",
    "parameters": {
      "type": "object",
      "properties": {
        "location": {
          "type": "string",
          "description": "The city and state, e.g. San Francisco, CA"
        },
        "unit": {
          "type": "string",
          "enum": ["celsius", "fahrenheit"],
          "description": "The unit for the temperature"
        }
      },
      "required": ["location"]
    }
  },
  {
    "name": "get_stock_price",
    "description": "Get the current stock price for a given symbol",
    "parameters": {
      "type": "object",
      "properties": {
        "symbol": {
          "type": "string",
          "description": "The stock ticker symbol, e.g. AAPL"
        }
      },
      "required": ["symbol"]
    }
  },
  {
      "name": "search_web",
      "description": "Search the web for information",
      "parameters": {
          "type": "object",
          "properties": {
              "query": {
                  "type": "string",
                  "description": "The search query"
              }
          },
          "required": ["query"]
      }
  }
]
```

Now, let's create a script (e.g., in Node.js) that takes this JSON and generates the TypeScript code.

**1. Helper Function to Convert JSON Schema Type to Zod Type**

```javascript
// zodTypeMapper.js (Helper function)
import { z } from 'zod'; // We need z locally to reference its types, but the output is string

function getZodType(propDefinition, isRequired) {
  let zodType;

  switch (propDefinition.type) {
    case 'string':
      if (propDefinition.enum) {
        // z.enum(['val1', 'val2'])
        const enumValues = propDefinition.enum.map(val => `'${val}'`).join(', ');
        zodType = `z.enum([${enumValues}])`;
      } else {
        zodType = 'z.string()';
      }
      break;
    case 'number':
      zodType = 'z.number()';
      break;
    case 'integer': // JSON Schema often uses integer, map to number
      zodType = 'z.number().int()';
      break;
    case 'boolean':
      zodType = 'z.boolean()';
      break;
    case 'array':
      // Basic array support - assumes simple types for items for now
      // TODO: Add recursive support for complex item types if needed
      const itemType = propDefinition.items && propDefinition.items.type
        ? getZodType(propDefinition.items, true).replace(/\.optional\(\)/, '') // Items in array are usually required within the array structure
        : 'z.any()'; // Default to z.any() if item type is not specified
       zodType = `z.array(${itemType})`;
       break;
    case 'object':
       // For simplicity, we won't handle nested objects directly in this basic example
       // You would need a recursive approach for full support.
       console.warn(`Nested object type for property not fully supported in this basic generator. Using z.object({}).`);
       zodType = 'z.object({})'; // Placeholder
       break;
    default:
      zodType = 'z.any()'; // Fallback for unknown types
  }

  if (propDefinition.description) {
    // Escape backticks and potentially other characters in description
    const escapedDescription = propDefinition.description.replace(/`/g, '\\`').replace(/\$/g, '\\$');
    zodType += `.describe(\`${escapedDescription}\`)`;
  }

  if (!isRequired) {
    zodType += '.optional()';
  }

  return zodType;
}

export { getZodType };

```

**2. Main Generation Script**

```javascript
// generateTools.js
import fs from 'fs';
import path from 'path';
import { getZodType } from './zodTypeMapper.js'; // Assuming helper is in the same dir

// --- Configuration ---
const inputJsonPath = './tools.json'; // Path to your input JSON file
const outputTsPath = './generatedTools.ts'; // Path for the generated TypeScript file
// ---

function generateToolDefinition(toolJson) {
  const { name, description, parameters } = toolJson;

  if (!name || !description) {
    console.warn(`Skipping tool due to missing name or description: ${JSON.stringify(toolJson)}`);
    return null;
  }

  // Sanitize name to be a valid JS variable name (simple version)
  const toolVariableName = name.replace(/[^a-zA-Z0-9_]/g, '_');

  let parametersString = 'z.object({})'; // Default if no parameters
  const parameterNames = [];

  if (parameters && parameters.type === 'object' && parameters.properties) {
    const properties = parameters.properties;
    const requiredParams = new Set(parameters.required || []);
    const propsString = Object.entries(properties)
      .map(([propName, propDefinition]) => {
        const isRequired = requiredParams.has(propName);
        parameterNames.push(propName); // Collect parameter names for execute signature
        const zodTypeString = getZodType(propDefinition, isRequired);
        // Indent property definition
        return `    ${propName}: ${zodTypeString}`;
      })
      .join(',\n');

    if (propsString) {
      // Add indentation for the object definition
      parametersString = `z.object({\n${propsString}\n  })`;
    }
  }

  // Create the execute function signature string
  const executeParamsString = parameterNames.length > 0 ? `{ ${parameterNames.join(', ')} }` : '{}';

  // Generate the tool code string
  // Use template literals for easier string construction and interpolation
  const toolCode = `
export const ${toolVariableName} = tool({
  description: '${description.replace(/'/g, "\\'")}', // Escape single quotes in description
  parameters: ${parametersString},
  execute: async (${executeParamsString}) => {
    // TODO: Implement the actual logic for the tool "${name}" here.
    // The parameters (${parameterNames.join(', ') || 'none'}) are available in the scope.
    console.log('Executing tool: ${name}', ${executeParamsString});

    // Example placeholder return value:
    // Replace this with the actual result of your tool's execution.
    // The return value structure depends on what the AI expects or what you need downstream.
    return { success: true, message: 'Tool ${name} executed (placeholder)', /* add actual data here */ };

    // Example: If it was the weather tool:
    // return {
    //   location: location, // Assuming 'location' was a parameter
    //   temperature: 72,
    //   unit: unit || 'fahrenheit' // Assuming 'unit' was an optional parameter
    // };
  },
});
`;

  return toolCode;
}

function generateToolsFile(toolsJsonArray, outputPath) {
  const imports = `import { tool } from 'ai';\nimport { z } from 'zod';\n\n`;
  let allToolCode = imports;

  for (const toolJson of toolsJsonArray) {
    const toolCode = generateToolDefinition(toolJson);
    if (toolCode) {
      allToolCode += toolCode + '\n'; // Add a newline between tools
    }
  }

  try {
    fs.writeFileSync(outputPath, allToolCode, 'utf8');
    console.log(`Successfully generated tool definitions at: ${outputPath}`);
  } catch (error) {
    console.error(`Error writing tools file to ${outputPath}:`, error);
  }
}

// --- Main Execution ---
try {
  const toolsJsonRaw = fs.readFileSync(inputJsonPath, 'utf8');
  const toolsJsonArray = JSON.parse(toolsJsonRaw);

  if (!Array.isArray(toolsJsonArray)) {
     throw new Error('Input JSON must be an array of tool definitions.');
  }

  generateToolsFile(toolsJsonArray, outputTsPath);

} catch (error) {
  console.error(`Error processing tool generation:`, error);
  process.exit(1); // Exit with error code
}
```

**3. How to Use:**

1.  **Save the code:**
    *   Save the first block as `zodTypeMapper.js`.
    *   Save the second block as `generateTools.js`.
2.  **Create your JSON:** Create a file named `tools.json` (or whatever you set in `inputJsonPath`) in the same directory, containing your tool definitions in the JSON format shown earlier.
3.  **Install Dependencies:** You'll need Node.js and potentially `zod` if you want type checking within the generator script itself (though it's not strictly required just to *generate* the code string). The *generated* code will definitely need `ai` and `zod`.
    ```bash
    npm install zod # Or yarn add zod
    # You'll need 'ai' and 'zod' in the project where you USE the generated code
    # npm install ai zod
    ```
4.  **Run the generator:**
    ```bash
    node generateTools.js
    ```
5.  **Check the output:** A file named `generatedTools.ts` (or your configured `outputTsPath`) will be created containing the TypeScript code.

**Generated Output (`generatedTools.ts` based on the example JSON):**

```typescript
import { tool } from 'ai';
import { z } from 'zod';

export const get_weather = tool({
  description: 'Get the current weather in a given location',
  parameters: z.object({
    location: z.string().describe(`The city and state, e.g. San Francisco, CA`),
    unit: z.enum(['celsius', 'fahrenheit']).describe(`The unit for the temperature`).optional()
  }),
  execute: async ({ location, unit }) => {
    // TODO: Implement the actual logic for the tool "get_weather" here.
    // The parameters (location, unit) are available in the scope.
    console.log('Executing tool: get_weather', { location, unit });

    // Example placeholder return value:
    // Replace this with the actual result of your tool's execution.
    // The return value structure depends on what the AI expects or what you need downstream.
    return { success: true, message: 'Tool get_weather executed (placeholder)', /* add actual data here */ };

    // Example: If it was the weather tool:
    // return {
    //   location: location, // Assuming 'location' was a parameter
    //   temperature: 72,
    //   unit: unit || 'fahrenheit' // Assuming 'unit' was an optional parameter
    // };
  },
});

export const get_stock_price = tool({
  description: 'Get the current stock price for a given symbol',
  parameters: z.object({
    symbol: z.string().describe(`The stock ticker symbol, e.g. AAPL`)
  }),
  execute: async ({ symbol }) => {
    // TODO: Implement the actual logic for the tool "get_stock_price" here.
    // The parameters (symbol) are available in the scope.
    console.log('Executing tool: get_stock_price', { symbol });

    // Example placeholder return value:
    // Replace this with the actual result of your tool's execution.
    // The return value structure depends on what the AI expects or what you need downstream.
    return { success: true, message: 'Tool get_stock_price executed (placeholder)', /* add actual data here */ };

    // Example: If it was the weather tool:
    // return {
    //   location: location, // Assuming 'location' was a parameter
    //   temperature: 72,
    //   unit: unit || 'fahrenheit' // Assuming 'unit' was an optional parameter
    // };
  },
});

export const search_web = tool({
  description: 'Search the web for information',
  parameters: z.object({
    query: z.string().describe(`The search query`)
  }),
  execute: async ({ query }) => {
    // TODO: Implement the actual logic for the tool "search_web" here.
    // The parameters (query) are available in the scope.
    console.log('Executing tool: search_web', { query });

    // Example placeholder return value:
    // Replace this with the actual result of your tool's execution.
    // The return value structure depends on what the AI expects or what you need downstream.
    return { success: true, message: 'Tool search_web executed (placeholder)', /* add actual data here */ };

    // Example: If it was the weather tool:
    // return {
    //   location: location, // Assuming 'location' was a parameter
    //   temperature: 72,
    //   unit: unit || 'fahrenheit' // Assuming 'unit' was an optional parameter
    // };
  },
});

```

**Key Points:**

*   **`execute` Function:** The generator creates a placeholder `execute` function. You **must** replace the `// TODO:` section and the placeholder `return` statement with your actual tool logic.
*   **Type Mapping:** The `getZodType` helper handles basic JSON schema types (string, number, boolean, enum, basic array). You might need to extend it for more complex scenarios like nested objects or more detailed array validation.
*   **Required Fields:** It correctly identifies required fields from the JSON `required` array and makes non-required fields optional using `.optional()` in Zod.
*   **Error Handling:** Basic error handling is included for file reading/writing and JSON parsing.
*   **Customization:** You can modify the `generateTools.js` script to change output paths, add more complex logic, or handle different JSON structures if needed.
